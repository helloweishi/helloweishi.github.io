<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Wei</title>
    <description>Welcome to Wei's blog.</description>
    <link>http://helloweishi.github.io//</link>
    <atom:link href="http://helloweishi.github.io//feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>Layer 2 Bridge Stack</title>
        <description>&lt;p&gt;In this post, I will talk about L2 architecture in Linux kernel network stack, focus on data flow, how packets receiving in, and route out. About network topology maintaining, like STP, I won&amp;rsquo;t talk here.  &lt;/p&gt;

&lt;h3 id=&quot;how-packets-receiving-in-?&quot;&gt;how packets receiving in ?&lt;/h3&gt;

&lt;p&gt;Hardware interrupt will raise when packets arrive, hardware driver deliver packets to CPU input queue via &lt;code&gt;netif_rx&lt;/code&gt;, which define in file net/core/dev.c, and then, raise Softirq &lt;code&gt;NET_RX_SOFTIRQ&lt;/code&gt;, and packets are received into layer 2 in Softirq handler, check the initialize part:  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__init&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;net_dev_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;open_softirq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NET_TX_SOFTIRQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;net_tx_action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;open_softirq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NET_RX_SOFTIRQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;net_rx_action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;net_rx_action&lt;/code&gt; is used to receive packets from CPU input queue, it will call &lt;code&gt;netif_receive_skb&lt;/code&gt;, then &lt;code&gt;__netif_receive_skb_core&lt;/code&gt;, which is the main function to route packets, let&amp;rsquo;s check this function in detail:  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;    &lt;span class=&quot;n&quot;&gt;list_for_each_entry_rcu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptype_all&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptype&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptype&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;skb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pt_prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;deliver_skb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;skb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pt_prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;orig_dev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;pt_prev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;ptype_all&lt;/code&gt; is used for delivering packet from kernel to user space directly, bypassing L2, and L3 firewall system, but it just copy packets into user space, and don&amp;rsquo;t stop here, the original packets processing continue. Packets capturing tools, like wireshark, sniffer, use this to capture all packets, and we can register HOOK at &lt;code&gt;ptype_all&lt;/code&gt; list to receive specific kind of packets via creating L2 socket.  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vlan_tx_tag_present&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;skb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pt_prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;deliver_skb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;skb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pt_prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;orig_dev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;pt_prev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vlan_do_receive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;skb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;goto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;another_round&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unlikely&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;skb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;goto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;VLAN process here, if receiving interface is in bridge, it won&amp;rsquo;t reach here, because packets already route out in bridge with VLAN header, code here is for packets reaching local host, it takes off VLAN header before delivering up.  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;    &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;skb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;protocol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;list_for_each_entry_rcu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptype_base&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ntohs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PTYPE_HASH_MASK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptype&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptype&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;null_or_dev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptype&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;skb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt;
             &lt;span class=&quot;n&quot;&gt;ptype&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;orig_dev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pt_prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;deliver_skb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;skb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pt_prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;orig_dev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;pt_prev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pt_prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unlikely&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;skb_orphan_frags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;skb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GFP_ATOMIC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;goto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;drop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pt_prev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;skb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;skb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pt_prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;orig_dev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;ptype_base&lt;/code&gt; is receiving HOOK list of L3 protocol, when network layer init, all supported protocol will register on this list, like IPV4, IPV6, when L3 protocol find on this list, packets will deliver into layer 3, or it will be dropped, code will reach here when receiving interface is not in bridge, or packets&amp;rsquo;s target MAC is local host, which will go into bridge stack first, and then route back.  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;    &lt;span class=&quot;n&quot;&gt;rx_handler&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rcu_dereference&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;skb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx_handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx_handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pt_prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;deliver_skb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;skb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pt_prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;orig_dev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;pt_prev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx_handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;skb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;RX_HANDLER_CONSUMED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NET_RX_SUCCESS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;goto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;RX_HANDLER_ANOTHER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;goto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;another_round&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;RX_HANDLER_EXACT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;deliver_exact&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;RX_HANDLER_PASS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;BUG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;rx_handler&lt;/code&gt; is the entry point to deliver packet into bridge stack, check &lt;code&gt;br_add_if&lt;/code&gt; in file &lt;code&gt;net/bridge/br_if.c&lt;/code&gt;, we can see when network interface add into bridge, its &lt;code&gt;rx_handler&lt;/code&gt; will assign to &lt;code&gt;br_handle_frame&lt;/code&gt;.  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;br_add_if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;net_bridge&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;br&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;net_device&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;netdev_rx_handler_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;br_handle_frame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;goto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It may have some differences from version to version in Linux kernel, like delivering packets optimization from physical layer to data link layer, its optimizing direction is minimize the frequency of IRQ, but the main steps always the same, the code I show here is kernel version 3.13.  &lt;/p&gt;

&lt;h3 id=&quot;bridge-stack&quot;&gt;Bridge Stack&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/bridge_stack.png&quot; alt=&quot;bridge stack&quot;&gt;
&lt;center&gt;&lt;small&gt;Figure 1: Bridge Stack framework&lt;/small&gt;&lt;/center&gt;  &lt;/p&gt;

&lt;p&gt;as we can see from figure above, when packets enter into bridge stack via &lt;code&gt;br_handle_frame&lt;/code&gt;, the first HOOK it need to go through is &lt;code&gt;NF_BR_PRE_ROUTING&lt;/code&gt;, there are many hook operations linked on every HOOK, and every hook operation has its priority.&lt;br&gt;
First, let&amp;rsquo;s check this priority structure, it is a enumerate, define in file  &lt;code&gt;include/linux/netfilter_bridge.h&lt;/code&gt;:  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nf_br_hook_priorities&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;NF_BR_PRI_FIRST&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INT_MIN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;NF_BR_PRI_NAT_DST_BRIDGED&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;300&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;NF_BR_PRI_FILTER_BRIDGED&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;NF_BR_PRI_BRNF&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;NF_BR_PRI_NAT_DST_OTHER&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;NF_BR_PRI_FILTER_OTHER&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;NF_BR_PRI_NAT_SRC&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;300&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;NF_BR_PRI_LAST&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INT_MAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Hook operations with priority value &lt;code&gt;NF_BR_PRI_FIRST&lt;/code&gt; have the highest priority, they will be executed before other rules, the implementation is simple, it is just a list, hook operations with low value are inserted toward head, and high value are inserted toward tail, and what about hook operations with the same priority ?  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;nf_register_hook&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nf_hook_ops&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nf_hook_ops&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mutex_lock_interruptible&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nf_hook_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;list_for_each_entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nf_hooks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hooknum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;priority&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elem&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;priority&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;list_add_rcu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elem&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mutex_unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nf_hook_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#if defined(CONFIG_JUMP_LABEL)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;static_key_slow_inc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nf_hooks_needed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hooknum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#endif&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;From code above, it is not difficult to see that hook operation inserted later will be executed first in the hook operations with the same priority.  &lt;/p&gt;

&lt;p&gt;Every hook operation has a hook function attached, when it get reached on list, its hook function will be executed.  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nf_hook_ops&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_head&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/* User fills in from here down. */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;nf_hookfn&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hook&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;owner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;priv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;u_int8_t&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;pf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;hooknum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/* Hooks are ordered in ascending priority. */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;priority&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let&amp;rsquo;s look at one example:  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nf_hook_ops&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ebt_ops_filter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__read_mostly&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hook&lt;/span&gt;       &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ebt_in_hook&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;owner&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;THIS_MODULE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pf&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NFPROTO_BRIDGE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hooknum&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NF_BR_LOCAL_IN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;priority&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NF_BR_PRI_FILTER_BRIDGED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hook&lt;/span&gt;       &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ebt_in_hook&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;owner&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;THIS_MODULE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pf&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NFPROTO_BRIDGE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hooknum&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NF_BR_FORWARD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;priority&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NF_BR_PRI_FILTER_BRIDGED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hook&lt;/span&gt;       &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ebt_out_hook&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;owner&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;THIS_MODULE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pf&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NFPROTO_BRIDGE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hooknum&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NF_BR_LOCAL_OUT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;priority&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NF_BR_PRI_FILTER_OTHER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is the filter system in bridge stack, it consists of three hook operations, which registered on &lt;code&gt;NF_BR_LOCAL_IN&lt;/code&gt;, &lt;code&gt;NF_BR_FORWARD&lt;/code&gt;, and &lt;code&gt;NF_BR_LOCAL_OUT&lt;/code&gt;, each hook operation has a hook function, we can add filter rules via command ebtables, in kernel, it just link that rule into filter rule list, when filter hook operation get reached on each HOOK, hook function, such as &lt;code&gt;ebt_in_hook&lt;/code&gt;, and &lt;code&gt;ebt_out_hook&lt;/code&gt;, will iterate filter rule list, and each rule in filter rule list of that HOOK will be applied.  &lt;/p&gt;

&lt;h4 id=&quot;ok,-let&amp;#39;s-jump-into-the-framework-of-bridge-stack&quot;&gt;Ok, let&amp;rsquo;s jump into the framework of bridge stack&lt;/h4&gt;

&lt;h3 id=&quot;hook-nf_br_pre_routing&quot;&gt;HOOK &lt;code&gt;NF_BR_PRE_ROUTING&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;there are two hook operations registered on this HOOK, one with priority &lt;code&gt;NF_BR_PRI_NAT_DST_BRIDGED&lt;/code&gt;, one with priority &lt;code&gt;NF_BR_PRI_BRNF&lt;/code&gt;.&lt;br&gt;
The first hook operation is used for DNAT, it means we can change packets destination information, like destination MAC address, which we can add rules at NAT table via ebtables. 
The second hook operation will do some destination fix up if DNAT takes place, re-parse layer 3 header, and route packet.  &lt;/p&gt;

&lt;h3 id=&quot;hook-nf_br_forward&quot;&gt;HOOK &lt;code&gt;NF_BR_FORWARD&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;there are three hook operations registered on this HOOK, one with priority &lt;code&gt;NF_BR_PRI_FILTER_BRIDGED&lt;/code&gt;, one with priority &lt;code&gt;NF_BR_PRI_BRNF-1&lt;/code&gt;, and one with priority &lt;code&gt;NF_BR_PRI_BRNF&lt;/code&gt;.&lt;br&gt;
The first hook operation with hook function &lt;code&gt;ebt_in_hook&lt;/code&gt; will iterate filter rules registered on this HOOK, and return when one rule match.&lt;br&gt;
The second hook operation with hook function &lt;code&gt;br_nf_forward_ip&lt;/code&gt;, as the name imply, it used to forward IP packets, how? it let packet go through all hook operations registered on HOOK &lt;code&gt;NF_INET_FORWARD&lt;/code&gt; at layer 3, if not IP packets, it just let it pass through.&lt;br&gt;
The third hook operation with hook function &lt;code&gt;br_nf_forward_arp&lt;/code&gt;, it used to deal with ARP packet, packet will deliver to HOOK &lt;code&gt;NF_ARP_FORWARD&lt;/code&gt;. For ARP, its framework consists of three HOOK, which are &lt;code&gt;NF_ARP_IN&lt;/code&gt;, &lt;code&gt;NF_ARP_OUT&lt;/code&gt;, and &lt;code&gt;NF_ARP_FORWARD&lt;/code&gt;, details can be seen in file net/ipv4/arp.c.  &lt;/p&gt;

&lt;h3 id=&quot;hook-nf_br_local_in&quot;&gt;HOOK &lt;code&gt;NF_BR_LOCAL_IN&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;There are two hook operations registered on this HOOK, one with priority &lt;code&gt;NF_BR_PRI_FILTER_BRIDGED&lt;/code&gt;ï¼Œ and one with priority &lt;code&gt;NF_BR_PRI_BRNF&lt;/code&gt;.&lt;br&gt;
The first hook operation with hook function &lt;code&gt;ebt_in_hook&lt;/code&gt;, as mentioned above, it used for packet filtering.&lt;br&gt;
The second hook operation with hook function &lt;code&gt;br_nf_local_in&lt;/code&gt; will do some destination checking, packets will deliver up to layer 3 if destination is right, or packets will be drop.  &lt;/p&gt;

&lt;h3 id=&quot;hook-nf_br_local_out&quot;&gt;HOOK &lt;code&gt;NF_BR_LOCAL_OUT&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;There are two hook operations registered on this HOOK, one with priority &lt;code&gt;NF_BR_PRI_NAT_DST_OTHER&lt;/code&gt;, one with priority &lt;code&gt;NF_BR_PRI_FILTER_OTHER&lt;/code&gt;.&lt;br&gt;
The first hook operation with hook function &lt;code&gt;ebt_nat_out&lt;/code&gt; will iterate NAT rules registered on this HOOK, and return when one rule match.&lt;br&gt;
The second hook operation with hook function &lt;code&gt;ebt_out_hook&lt;/code&gt; will iterate filter rules registered on this hook, and return when one rule match.  &lt;/p&gt;

&lt;h3 id=&quot;hook-nf_br_post_routing&quot;&gt;HOOK &lt;code&gt;NF_BR_POST_ROUTING&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;There are two hook operations registered on this HOOK, one with priority &lt;code&gt;NF_BR_PRI_NAT_SRC&lt;/code&gt;, one with priority &lt;code&gt;NF_BR_PRI_LAST&lt;/code&gt;.&lt;br&gt;
The first hook operation with hook function &lt;code&gt;ebt_nat_out&lt;/code&gt;, as mentioned above, it is used for NAT.&lt;br&gt;
The second hook operation with hook function &lt;code&gt;br_nf_post_routing&lt;/code&gt; will deliver packets to HOOK &lt;code&gt;NF_INET_POST_ROUTING&lt;/code&gt; for IP, it will do some connection fix up if NAT takes place there, if not IP packets, it just pass it through.  &lt;/p&gt;

&lt;h3 id=&quot;how-packet-send-out-?&quot;&gt;how packet send out ?&lt;/h3&gt;

&lt;p&gt;After packets go through bridge stack, layer 2 header will be inserted into packets, and the API to send packets out is &lt;code&gt;dev_queue_xmit&lt;/code&gt;, if QOS is enabled, packets will be enqueued, or it will be deliver into network device&amp;rsquo;s transmit queue directly, and interrupt &lt;code&gt;NET_TX_SOFTIRQ&lt;/code&gt; raise, packets are delivered down.  &lt;/p&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;conclusion&lt;/h3&gt;

&lt;p&gt;From the framework of bridge stack, we can see there are several hook operations registered on each HOOK, each hook operation has one priority, which determine its execution order. During our development, we can extend hook operations on each HOOK dynamically based on our needs, what we should take care about is their priority and what character each HOOK is in framework.  &lt;/p&gt;
</description>
        <pubDate>Sat, 27 Jun 2015 20:33:00 +0800</pubDate>
        <link>http://helloweishi.github.io//network/stack/2015/06/27/L2-bridge-stack/</link>
        <guid isPermaLink="true">http://helloweishi.github.io//network/stack/2015/06/27/L2-bridge-stack/</guid>
      </item>
    
      <item>
        <title>Linux Kernel Network Framework</title>
        <description>&lt;p&gt;Talking about network, I believe everyone knows Internet, each day, we live and work, we can&amp;rsquo;t get ride of it. but how our computer, or phone talk to each other, or how network works, that alway be the interesting thing we like to know, it is a new world of our lives, it is the basic of communication, which connect all of us.  &lt;/p&gt;

&lt;p&gt;In this series, I like to show something about network, I hopes it can help you to figure out how network works. To make network manageable, and network devices can communicate with each other, no matter what OS they run, we need some unified rules to define how network device should react when it receives something from others, which came out a global network organization, it created a unified network model, which splits network into 7 layers, each layer has its own mission and self-defined functionality, which includes what information it should take, how it should communication with other layers, etc. These layers are &lt;strong&gt;physical layer&lt;/strong&gt;, &lt;strong&gt;data link layer&lt;/strong&gt;, &lt;strong&gt;network layer&lt;/strong&gt;, &lt;strong&gt;transport layer&lt;/strong&gt;, &lt;strong&gt;session layer&lt;/strong&gt;, &lt;strong&gt;representation layer&lt;/strong&gt;, and &lt;strong&gt;application layer&lt;/strong&gt;, but to keep things simple, in practical use, we merged session layer and representation layer into application layer, which become only 5 layer in practice.  &lt;/p&gt;

&lt;p&gt;&lt;big&gt;&lt;strong&gt;Functionality definition&lt;/strong&gt;&lt;/big&gt;:&lt;br&gt;
&lt;strong&gt;Physical Layer&lt;/strong&gt;: it provides capability that network message transmit on physical media.&lt;br&gt;
&lt;strong&gt;Data Link Layer&lt;/strong&gt;: it defines local address, which locatable in local network, provide network management capability in local network.&lt;br&gt;
&lt;strong&gt;Network Layer&lt;/strong&gt;: it defines global address database, which locatable in global network.&lt;br&gt;
&lt;strong&gt;Transport Layer&lt;/strong&gt;: it provides connection management capability.&lt;br&gt;
&lt;strong&gt;Application Layer&lt;/strong&gt;: it provides communication capability between network devices, convert messages into human readable format.  &lt;/p&gt;

&lt;p&gt;In Linux, there are 4 layers in the bottom implemented in kernel space, and application layer is implemented in user space, in this series, I mainly focus on kernel stack, the major part of physical layer is device driver of hardware, it differ from media to media, like WIFI, Ethernet, ATM, GPON,  etc, so in Linux kernel, the most unified part is from data link layer to transport layer, and that is my topic.  &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Network_framework_state.png&quot; alt=&quot;network framework&quot;&gt;
&lt;center&gt;&lt;small&gt;Figure 1: Linux kernel network framework&lt;/small&gt;&lt;/center&gt;  &lt;/p&gt;

&lt;h2 id=&quot;data-link-layer&quot;&gt;Data Link Layer&lt;/h2&gt;

&lt;p&gt;In order to communication with physical layer, it provide something interfaces, like network interrupt handler, poll API, etc, which can deliver packets up and down.&lt;br&gt;
Receiving data from physical layer, it usually do in interrupt, as network throughput capability goes higher, it already become a bottleneck, so there are several optimization here, like NAPI, network interrupt threading.&lt;br&gt;
If source network interface data received from is inside bridge, data will be delivered into bridge stack, or it will take off layer 2 header and deliver packets up to network layer.&lt;br&gt;
when there are some packet need to send out, it will insert its layer 2 header, like MAC address, VLAN, etc, into packet, and deliver packet to target network interface&amp;rsquo;s transmitting queue.&lt;br&gt;
In bridge stack, packets will be handled based on layer 2 header, like MAC address, VLAN, briefly speaking, packets in bridge stack have two direction, one is deliver packet up to network layer if target MAC address is local machine, the other is deliver packets down to physical layer if target MAC address is other host, before reaching target, packets need to pass through layer 2 firewall system.  &lt;/p&gt;

&lt;h2 id=&quot;network-layer&quot;&gt;Network Layer&lt;/h2&gt;

&lt;p&gt;when network layer init, it registers its supported layer 3 protocol type in a linked list, like IPV4, IPV6, and provide a receiving HOOK function, like ip_rcv for IPV4, which used to receive packets from layer 2, so when data link layer deliver packets up, it will iterate this linked list, and call its receiving HOOK function if layer 3 protocol match.&lt;br&gt;
In network layer, packets will be handled based on IP header, its target direction depends on the result of route table look-up, up to transport layer if target IP address is local machine, or down to data link layer if target IP address is other host, before reaching target, packets need to pass through layer 3 firewall system.&lt;br&gt;
when packet need to deliver up to transport layer, it will take off layer 3 header before delivering.&lt;br&gt;
when packet need to deliver down to data link layer, it will insert layer 3 header based on the result of route table look-up, and deliver packets to target transmitting queue.  &lt;/p&gt;

&lt;h2 id=&quot;transport-layer&quot;&gt;Transport Layer&lt;/h2&gt;

&lt;p&gt;The major task in this layer is connection management, whenever devices communicate, they need to establish a connection first, it is done on this layer via socket, which create a structure called &lt;code&gt;struct sock&lt;/code&gt; to record and maintain all the information of this connection, and insert it into hash table of each supported protocol, like UDP, TCP.&lt;br&gt;
when network layer deliver packets up, it will find the connection related in hash table, if succeed, it take off layer 4 header, append packets into socket&amp;rsquo;s receiving queue, and wake up application in user space, which will receive packets into application layer, if no connection find in hash table, packets will be dropped. 
when application send message down, it store at socket&amp;rsquo;s transmitting queue, transport layer will dequeue from transmitting queue, and find the destination in route table based on information in &lt;code&gt;struct sock&lt;/code&gt;, before delivering packets down, it will fill layer 4 header, and calculate checksum.  &lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;conclusion&lt;/h2&gt;

&lt;p&gt;each layer in Linux kernel is self-organized, it just cares what input from neighbor layers, what output to neighbor layers, which have better simplicity and flexibility. When deliver packet down and up, it just manipulate the data pointer, no real memory operation, it can benefit memory management, and make data delivering between layers faster. Kernel use linked list and hash table to manage protocol in each layer, it can grow up dynamically, and protocol designing is modularized, so it can keeping updating at runtime, it offer much scalability, and we can benefit from this design technique, for our design, we can learn a lot from it.  &lt;/p&gt;

&lt;p&gt;This is the whole network stack framework in Linux kernel, actually, they are a lot I don&amp;rsquo;t show here, in next post, I will focus the details in each layers, any questions, don&amp;rsquo;t hesitate to drop me a email.  &lt;/p&gt;
</description>
        <pubDate>Mon, 18 May 2015 19:54:00 +0800</pubDate>
        <link>http://helloweishi.github.io//network/stack/2015/05/18/Linux-kernel-network-framework/</link>
        <guid isPermaLink="true">http://helloweishi.github.io//network/stack/2015/05/18/Linux-kernel-network-framework/</guid>
      </item>
    
      <item>
        <title>Defense RST attack from firewall</title>
        <description>&lt;p&gt;Keywords filtering system is one of filtering mechanism in firewall, it can make the connection broken immediately, and the service we visit will stop, one simple example is we search something via Google, browser display connection reset, right after we input the search keywords.  &lt;/p&gt;

&lt;p&gt;In order to explain how we can fix it up, I introduce some data structure first:  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
struct proto tcp_prot = {  
        .name                   = &quot;TCP&quot;,  
        .owner                  = THIS_MODULE,  
        .close                  = tcp_close,  
        .connect                = tcp_v4_connect,  
        .disconnect             = tcp_disconnect,  
        .accept                 = inet_csk_accept,  
        .ioctl                  = tcp_ioctl,  
        .init                   = tcp_v4_init_sock,  
        .destroy                = tcp_v4_destroy_sock,  
        .shutdown               = tcp_shutdown,  
        .setsockopt             = tcp_setsockopt,  
        .getsockopt             = tcp_getsockopt,  
        .recvmsg                = tcp_recvmsg,  
        .sendmsg                = tcp_sendmsg,  
        .sendpage               = tcp_sendpage,  
        .backlog_rcv            = tcp_v4_do_rcv,  
        .release_cb             = tcp_release_cb,  
        .hash                   = inet_hash,  
        .unhash                 = inet_unhash,  
        .get_port               = inet_csk_get_port,  
        .enter_memory_pressure  = tcp_enter_memory_pressure,  
        .stream_memory_free     = tcp_stream_memory_free,  
        .sockets_allocated      = &amp;tcp_sockets_allocated,  
        .orphan_count           = &amp;tcp_orphan_count,  
        .memory_allocated       = &amp;tcp_memory_allocated,  
        .memory_pressure        = &amp;tcp_memory_pressure,  
        .sysctl_mem             = sysctl_tcp_mem,  
        .sysctl_wmem            = sysctl_tcp_wmem,  
        .sysctl_rmem            = sysctl_tcp_rmem,  
        .max_header             = MAX_TCP_HEADER,  
        .obj_size               = sizeof(struct tcp_sock),  
        .slab_flags             = SLAB_DESTROY_BY_RCU,  
        .twsk_prot              = &amp;tcp_timewait_sock_ops,  
        .rsk_prot               = &amp;tcp_request_sock_ops,  
        .hashinfo             = &amp;tcp_hashinfo,  
        .no_autobind            = true,  
#ifdef CONFIG_COMPAT  
        .compat_setsockopt      = compat_tcp_setsockopt,  
        .compat_getsockopt      = compat_tcp_getsockopt,  
#endif  
#ifdef CONFIG_MEMCG_KMEM  
        .init_cgroup            = tcp_init_cgroup,  
        .destroy_cgroup         = tcp_destroy_cgroup,  
        .proto_cgroup           = tcp_proto_cgroup,  
#endif  
};  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Struct proto tcp_prot is the central structure of TCP protocol in Linux kernel, which define in file net/ipv4/tcp_ipv4.c, all the connection control and packets in/out are hanled by HOOK functions in this structure, like HOOK function backlog_rcv receive packets from layer 3, and deliver them to upper layer.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
struct inet_sock {  
    /* sk and pinet6 has to be the first two members of inet_sock */  
    struct sock     sk;  
#if IS_ENABLED(CONFIG_IPV6)  
    struct ipv6_pinfo   *pinet6;  
#endif  
    /* Socket demultiplex comparisons on incoming packets. */  
#define inet_daddr      sk.__sk_common.skc_daddr  
#define inet_rcv_saddr      sk.__sk_common.skc_rcv_saddr  
#define inet_dport      sk.__sk_common.skc_dport  
#define inet_num        sk.__sk_common.skc_num  
   
    __be32          inet_saddr;  
    __s16           uc_ttl;  
    __u16           cmsg_flags;  
    __be16          inet_sport;  
    __u16           inet_id;  
  
    struct ip_options_rcu __rcu *inet_opt;  
    int         rx_dst_ifindex;  
    __u8            tos;  
    __u8            min_ttl;  
    __u8            mc_ttl;  
    __u8            pmtudisc;  
    __u8            recverr:1,  
                is_icsk:1,  
                freebind:1,  
                hdrincl:1,  
                mc_loop:1,  
                transparent:1,  
                mc_all:1,  
                nodefrag:1;  
    __u8            rcv_tos;  
    __u8            convert_csum;  
    int         uc_index;  
    int         mc_index;  
    __be32          mc_addr;  
    struct ip_mc_socklist __rcu *mc_list;  
    struct inet_cork_full   cork;  
};    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Struct inet_sock maintains network elements of connection established, like IP addresses and ports of foreign and local, TOS value, outgoing device index, etc, and it is embedded in struct sock sk, which is the central structure of socket, and which controls and maintains all the states of connection, we can use inet_sk(sk) call to get struct inet_sock information from struct sock. There are two elements related to TTL in struct inet_sock I like to mention here, uc_ttl is TTL for local machine, TTL in IP header will take its value when send out, if its value is not -1, which is the value when socket init, but we can set its value via ioctl; mc_ttl is TTL for multicasting, for unicast, there is no use, so we can use it to record TTL value received from peer, which can help us to fixup RST attack, when socket init, mc_ttl is set to 1.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#code segement of function inet_create, when socket init.  
    inet-&amp;gt;inet_id = 0;  

    sock_init_data(sock, sk);  

    sk-&amp;gt;sk_destruct    = inet_sock_destruct;  
    sk-&amp;gt;sk_protocol    = protocol;  
    sk-&amp;gt;sk_backlog_rcv = sk-&amp;gt;sk_prot-&amp;gt;backlog_rcv;  

    inet-&amp;gt;uc_ttl    = -1;  
    inet-&amp;gt;mc_loop   = 1;  
    inet-&amp;gt;mc_ttl    = 1;  
    inet-&amp;gt;mc_all    = 1;  
    inet-&amp;gt;mc_index  = 0;  
    inet-&amp;gt;mc_list   = NULL;  
    inet-&amp;gt;rcv_tos   = 0;   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ok, let&amp;rsquo;s start to dig code to find out how TCP socket works in Linux kernel, to simplify the case, I only talk about receiving diretion.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/tcpflow.png&quot; alt=&quot;TCP FLOW&quot;&gt;
&lt;center&gt;&lt;small&gt;Figure 1: TCP receive flow&lt;/small&gt;&lt;/center&gt;  &lt;/p&gt;

&lt;p&gt;when socket start, we are client, we start the connection, after socket init, 3 way hand shake start:&lt;br&gt;
HOOK function connect, for TCP tcp_v4_connect, send SYN to server, and set TCP socket state to TCP_SYN_SENT;&lt;br&gt;
Server reply SYN ACK, it is handled by HOOK function backlog_rcv, tcp_v4_do_rcv in TCP, it calls tcp_rcv_state_process to deal with state TCP_SYN_SENT;&lt;br&gt;
tcp_synsent_state_process called to handle SYN ACK from server, it send SYN ACK back to server, and set TCP socket state to TCP_ESTABLISHED, if TCP flags server send are not SYN ACK, like RST, it will deal with in different way.  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#TTL record in tcp_synsent_state_process  
 we can record TTL value from server here after tcp state to TCP_ESTABLISHED  
# code segement  
inet_sk(sk)-&amp;gt;mc_ttl = ip_hdr(skb)-&amp;gt;ttl;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;after connection established, HOOK backblog_rcv will handle stream in fast path under the condition of flag in TCP header match flag in previous packet, it calls tcp_rcv_established, if there is one packet with flag RST recevie, it will obvious make flag unmatch with previous one, and packet will go to slow path, tcp_validate_incoming will be called to handled the exception, which define in net/ipv4/tcp_input.c.  &lt;/p&gt;

&lt;p&gt;In tcp_validate_incoming, flags checking plays significant role, including RST flag checking.  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#code segment of function tcp_validate_incoming  
    /* Step 2: check RST bit */  
    if (th-&amp;gt;rst) {  
        /* RFC 5961 3.2 :  
         * If sequence number exactly matches RCV.NXT, then  
         *     RESET the connection  
         * else  
         *     Send a challenge ACK  
         */  
        if (TCP_SKB_CB(skb)-&amp;gt;seq == tp-&amp;gt;rcv_nxt)  
            tcp_reset(sk);  
        else  
            tcp_send_challenge_ack(sk, skb);  
        goto discard;  
    }  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;By default, tcp_reset will be called to terminate the connection, if RST flag set.&lt;br&gt;
Defense attack fixup:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#code segment of function tcp\_validate\_incoming  
    /* Step 2: check RST bit */  
    if (th-&amp;gt;rst) {  
        /* RFC 5961 3.2 :  
         * If sequence number exactly matches RCV.NXT, then  
         *     RESET the connection  
         * else  
         *     Send a challenge ACK  
         */  
       /* if TTL difference between RST and SYN packet received from peer more than 4, ignore RST, it is potential attack */  
       if (inet_sk(sk)-&amp;gt;mc_ttl &amp;gt; 1 &amp;amp;&amp;amp; abs(ip_hdr(skb)-&amp;gt;ttl - inet_sk(sk)-&amp;gt;mc_ttl) &amp;gt; 4)  
           goto discard;  
        else if (TCP_SKB_CB(skb)-&amp;gt;seq == tp-&amp;gt;rcv_nxt)  
            tcp_reset(sk);  
        else  
            tcp_send_challenge_ack(sk, skb);  
        goto discard;  
    }  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Fix me, if you find something wrong in my article, Thanks.&lt;/p&gt;
</description>
        <pubDate>Sat, 25 Apr 2015 19:54:00 +0800</pubDate>
        <link>http://helloweishi.github.io//network/firewall/2015/04/25/defense-RST-attack-from-firewall/</link>
        <guid isPermaLink="true">http://helloweishi.github.io//network/firewall/2015/04/25/defense-RST-attack-from-firewall/</guid>
      </item>
    
      <item>
        <title>Visit twitter inside firewall without VPN</title>
        <description>&lt;p&gt;Like &lt;a href=&quot;/network/firewall/2015/04/03/access-youtube-without-vpn/&quot;&gt;youtube&lt;/a&gt; and &lt;a href=&quot;/network/firewall/2015/03/02/access-google-without-vpn/&quot;&gt;google&lt;/a&gt;, twitter is blocked in the same way, if you want to know how firewall filter system works, you can read my previous articles, this article I introduce some ways to walk around firewall, and visit twitter freely.&lt;br&gt;
The main idea is avoid any DNS packets send out for all blocked sites, when visit twitter, we should find out the IP addresses of blocked sites servers, which reachable, and append them into host file.  &lt;/p&gt;

&lt;p&gt;how can we know all the blocked sites ?&lt;br&gt;
we can find them out following steps below:&lt;br&gt;
1)  open capture tool, like warshark, or sniffer, and start to capture packets&lt;br&gt;
2)  input twitter.com into your browser&lt;br&gt;
3)  when browser notify connection time-out or connection reset, stop capturing&lt;br&gt;
4)  packet analyze, we need to check all the DNS reply, and the connection establish between our device and site&amp;rsquo;s server IP address in DNS reply, if that server never answer our device&amp;rsquo;s request, or connection reset by server, which TTL value is obvious different with other packets in the same connection, they will be the sites blocked by firewall.    &lt;/p&gt;

&lt;p&gt;After knowing all the blocked sites, the next step we need to do is find out valid IP addresses for all blocked sites, we can do it via ping these blocked site outside firewall, like online ping website in other countries, or iterate these sites&amp;rsquo;s IP pool.  &lt;/p&gt;

&lt;p&gt;For twitter, there are at least two sites, twitter.com and domain with suffix twimg.com, which server store images, like pbs.twimg.com, we need to find out these two sites&amp;rsquo;s IP addresses, and it seems not like google, all services can visit via a single server, in twitter, text and image store at different servers, so we should find them all, or web page won&amp;rsquo;t display normally.    &lt;/p&gt;

&lt;p&gt;The last step is append IP address and domain name into host file, flush DNS cache, and enjoy.  &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/twitter.png&quot; alt=&quot;twitter page&quot;&gt;
&lt;center&gt;&lt;small&gt;Figure 1: twitter snapshot&lt;/small&gt;&lt;/center&gt;  &lt;/p&gt;
</description>
        <pubDate>Wed, 22 Apr 2015 19:45:00 +0800</pubDate>
        <link>http://helloweishi.github.io//network/firewall/2015/04/22/visit-twitter-without-vpn/</link>
        <guid isPermaLink="true">http://helloweishi.github.io//network/firewall/2015/04/22/visit-twitter-without-vpn/</guid>
      </item>
    
      <item>
        <title>Visit youtube inside firewall without VPN</title>
        <description>&lt;p&gt;This article I like to introduce some technical details about how firewall system block Youtube service, and based on the analysis of filter mechanism, I will try to tell you how to break it.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Here we go.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/network/firewall/2015/03/02/access-google-without-vpn/&quot;&gt;In last article&lt;/a&gt;, I tried to analysis how firewall system block Google, which is &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;IP address filtering&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;keywords filtering&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;these two mechanism also work here, but there are a little difference in keywords filtering, when you visit Google&amp;rsquo;s search service, firewall system check GET/POST packets for your search keywords, it will trigger firewall system send RST packet to your device if some sensitive information found, for Youtube, firewall system still check GET/POST packets, but different header field in HTTP header, which is HOST, this header field is required in every HTTP request packets, its value is target&amp;rsquo;s domain name, firewall system can known which domain name you want to visit by checking this field-value, here it is youtube.com, so it will trigger firewall system send RST to your device.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Filtering Summarize&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The youtube service block mechanism: the first step is add youtube severs&amp;rsquo; IP addresses into black list, the second step is check HOST header field in HTTP header, which HTTP packet type is GET/POST, if it is youtube.com, fire RST.&lt;/p&gt;

&lt;p&gt;there is one question here, if you find a valid youtube server&amp;rsquo;s IP address, which is not in black list, and you input that IP address in browser, it doesn&amp;rsquo;t return youtube&amp;rsquo;s website to you, but Google&amp;rsquo;s search website. You know, Google has many services, youtube is one of them, that means Google&amp;rsquo;s IP pool is youtube&amp;rsquo;s IP pool, too, and it has Gmail, maps, docs, and etc, almost all of these services you can visit from the same server, actually, I don&amp;rsquo;t know how Google works, and it is not very possible that Google have all the services in the same server, I guess it must have some internal mechanism between Google servers, they can schedule other resources from other servers when they don&amp;rsquo;t have, and return to user directly, and don&amp;rsquo;t need user to visit other servers, this can simplify the procedure. In last article, I said when you found a valid Google server&amp;rsquo;s IP address, and just input that address in browser, Google will return you a search website, which is its default service, how we can visit Google other services from the same server ? from my investigation, this service discrimination lie in header field HOST of HTTP header, that is why firewall system use it to block youtube service, when you just input Google server&amp;rsquo;s IP address in browser, HOST is the IP address you input, Google don&amp;rsquo;t know which service you want to access, so it return its default service&amp;mdash;-search engine, if you visit its youtube service, HOST field-value is youtube.com, if Gmail, HOST field-value is gmail.google.com, if maps, HOST field-value is maps.google.com, and etc. &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/hostHeaderField.png&quot; alt=&quot;Host Header field&quot;&gt;
&lt;center&gt;&lt;small&gt;Figure 1: Host Header Field snapshot&lt;/small&gt;&lt;/center&gt;  &lt;/p&gt;

&lt;p&gt;you may ask how to make HOST field-value be the target service domain in HTTP header, or how to relate the target service domain with the IP address you specified? In order to answer this question, let&amp;rsquo;s talk about what exactly happens when you input a URL in browser.&lt;/p&gt;

&lt;p&gt;The first thing operator system want to know is where you want to visit, it decode what you input, if it is a IP address, operator system will establish a connection with server with that IP address, and get what you request; if it is domain name, operator system need to translate domain name into IP address, and then, establish a connection, get what you request.
how operator system translate domain name into IP address is very import part of this article, so I talk about it in detail, each OS, like windows, Linux, may have a little difference, but the main idea is the same, let&amp;rsquo;s first talk about Linux, Ubuntu, as a example, when it receive a domain name, where it first send DNS query to depends on the configure file /etc/resolv.conf, by default, the target DNS server is 127.0.0.1, that means it send DNS query to itself, Ubuntu handle DNS in proxy way, one dnsmasq process listens on port 53, which port is reserved for DNS, after dnsmasq receives DNS query, what it first do is check configuration file /etc/hosts, if there is a domain name in this file match domain in DNS query, it will return IP address configured for that domain directly, and no DNS query will send out, if no match, dnsmsq will send DNS query to DNS server configured on default WAN interface, when DNS response receives, it will return to application which is waiting, here it is browser, if no DNS response receives, dnsmasq will try several times till time out.&lt;/p&gt;

&lt;p&gt;Windows has a similar mechanism and similar hosts configuration file, it is C:\windows\system32\driver\etc\hosts. You know, for all the forbidden sites in firewall system, the most important thing is &lt;big&gt;avoid send any DNS query out, any IP addresses return from DNS servers inside firewall system are in black list&lt;/big&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Time To Break Restriction&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Break restriction 1:
For IP address blocking, in previous article, I already said how to find a valid IP address, skip it here.&lt;/p&gt;

&lt;p&gt;Break restriction 2:
after find a valid IP address, we can&amp;rsquo;t input it in browser directly, because Google won&amp;rsquo;t know which service you want to visit, need to do a little trick, configure IP address of domain youtube.com into hosts file,
like appending below to host file in your OS:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;(replace here with ip you find)            youtube.com ytimg.com google.com google.com.hk googlevideo.com&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;it works at windows OS, but Linux, that is because there is a little different when they search domain in hosts file, windows OS search domain&amp;rsquo;s suffix, if you configure google.com in hosts file, the target service domains all with suffix google.com, like maps.google.com, docs.google.com, can match in host file, and return IP address succeed, but Linux, it is strict match, that means google.com only match google.com, if the target service domain is maps.google.com, Linux will failed to find a entry in hosts file, that is weird, but it is not so difficult problem, change the match rule in dnsmasq, just several lines of code can fix it, and I will come up later when it is done. Without match rule change in dnsmasq, you still can open youtube site, but when you watch video, it will display error, that is because video&amp;rsquo;s service domain name is not a fixed one, but with some weird prefix, like r2&amp;mdash;xxxx.googlevideo.com, r4&amp;mdash;xxxx.googlevideo.com, so match rule in dnsmasq has to be changed before watching video.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/youtube1.png&quot; alt=&quot;youtube snapshot 1&quot;&gt;
&lt;center&gt;&lt;small&gt;Figure 2: youtube site snapshot&lt;/small&gt;&lt;/center&gt;&lt;br&gt;
&lt;img src=&quot;/images/youtube2.png&quot; alt=&quot;youtube snapshot 2&quot;&gt;
&lt;center&gt;&lt;small&gt;Figure 3: youtube site snapshot 2&lt;/small&gt;&lt;/center&gt;  &lt;/p&gt;

&lt;p&gt;And about keywords filter system in firewall, I think we have a way to ignore the RST packet firewall sending, in previous article, I talked about TTL, the TTL value your device receives from firewall system is much different with it from original server, for Linux system, we can fix it in kernel, when connection establishes, TTL value can record in socket structure, and if kernel receives RST, it can compare the TTL in RST with it in socket structure, which can tell whether this RST is send from original server, and I will come up later when it is done. &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Conclusion&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The usual methods firewall system used to block site accessing are IP filtering and keywords filtering. when we want to break through, the first thing is find a valid IP address, and second is avoid DNS query sending out, and use secure connection if server support, this technical I tested in Windows, Linux, I think IOS, too, just need to know how to configure it.&lt;/p&gt;

&lt;p&gt;Fix me if you find some wrong, and drop me email if you have questions.&lt;/p&gt;
</description>
        <pubDate>Fri, 03 Apr 2015 18:34:21 +0800</pubDate>
        <link>http://helloweishi.github.io//network/firewall/2015/04/03/access-youtube-without-vpn/</link>
        <guid isPermaLink="true">http://helloweishi.github.io//network/firewall/2015/04/03/access-youtube-without-vpn/</guid>
      </item>
    
      <item>
        <title>Visit Google inside firewall without VPN</title>
        <description>&lt;p&gt;I believe many people don&amp;rsquo;t like restrictions, we live in a equal world, we love freedom, but when you want to search something, you find you can&amp;rsquo;t even open that search engine&amp;rsquo;s main page, I believe you must feel bad, what&amp;rsquo;s going on there, it that a firewall system stuck your way ? &lt;/p&gt;

&lt;p&gt;So this article, I like to, from technical point of view, analysis how firewall works, why you request blocked, and how to break it.&lt;/p&gt;

&lt;p&gt;Here we go, for a firewall system, it will block your request if it know &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;it knows where you want to request and that destination is in black list&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;it knows what you want to request and it contains some sensitive information&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;For 1)&lt;/strong&gt;: when you type &amp;ldquo;www.google.com&amp;rdquo; in your browser, your PC/Phone will send DNS query to DNS server if your PC/Phone don&amp;rsquo;t have that domain&amp;rsquo;s IP address in DNS cache, or static configured, so one direct way to know where you want to request is check your DNS query, there are two way to block your request, &lt;/p&gt;

&lt;p&gt;option 1: Drop your DNS query, your DNS request can never reach DNS server;&lt;/p&gt;

&lt;p&gt;option 2: Reply you DNS query with wrong IP address, which is called DNS poison.&lt;/p&gt;

&lt;p&gt;In real appliance, blocking DNS query don&amp;rsquo;t block many requests, because DNS query can never reach firewall, all DNS servers we use by default are inside local ISP, normally, several routers away from your PC/Phone, so your DNS query can never go that far to firewall system, and you can try to configure your device&amp;rsquo;s DNS server to a foreign server, and check if firewall system will block your DNS query, or not.
normally, your device will get some valid IP addresses, and then, your device will send an SYN packet to IP address, which is Google server, and now, firewall system start to work, because there is no server inside, all the rest requests will go through firewall system, so here, it can drop your request directly for any requests to that Google server&amp;rsquo;s IP address, that is why you open your browser, type  &amp;ldquo;www.google.com&amp;rdquo;, and wait for a long time, and then, your browser display connection timeout.&lt;/p&gt;

&lt;p&gt;How firewall system know Google server&amp;rsquo;s IP address? especially, it is not just one, but many, it can know part of it, there are several ways to know that, one way is the corporation of ISP, ISP define a small IP pool of Google domain as DNS replying, firewall system can only block all IP in this pool, it can block all requests inside; another way is we can know who some public IP belong to via whois utility, for big company, it usually have a large IP pool, which we can find out via whois online. So for firewall system, it can not block that small IP pool ISP defined, it need more, and actually, it does. but it can not know all of them, and this will leave some space to us.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;For 2)&lt;/strong&gt;: In some period, you find you can open Google&amp;rsquo;s main page, but when you type some search keywords, your browser display connection reset immediately, that is another filter system, it not only check your request destination, but also check your request content, which do via pattern matching. normally, when you request Google service, your device will connect service port 80, which is HTTP request, it is plain text connection, everything you request can be seen by the router of routine, and every time you want to search something, its keywords you typed contain in type GET/POST kind of HTTP packets, firewall system can only check this two kind of packets, it will know what you want to request, and block it if sensitive, actually it is not forbid your request pass through, but send a RST packet to you device actively, which will make the connection between your device and Google server broken.&lt;/p&gt;

&lt;p&gt;Why firewall system don&amp;rsquo;t just drop you request packet, which will make your request never arrive Google server, and which you may think it is the simplest way, it will effect network throughput seriously if it does in this way, why? that is due to the design of network mode, it have 7 layers, but in real application, we just consider about 5 layers, which is physical layer, data link layer, network layer, transport layer, application layer from bottom up, IP information is contained in network layer, HTTP content is contained in application layer, for a router in the routine between your device and Google server, if it want to know what your request are, it have decode packets from your device bottom up, layer by layer, less layer it decode, faster packets can pass through, assume the time it take is the same each layer it decode, and it takes 1 second to forward one packet when it just decode one layer, if it decode two layer, it has to take 2 second, and etc, HTTP content is contained in application layer, can you image that ? it will be nightmare. Usually, router just need to decode three layers when forward, that means it just need to know where your request go, don&amp;rsquo;t care what your request are, for some network, they just decode two layers for throughput speed up, like using route protocol MPLS, it also called MPLS network. &lt;/p&gt;

&lt;p&gt;So for keywords filter system, I guess your HTTP request don&amp;rsquo;t pass through firewall directly, firewall is connected at the router, which forward your request packets to outside internet, when your request packets pass through, it will forward twice, one to outside internet, one to firewall, packet forward is pretty fast, it just sacrifice performance a little, or not at all. firewall will decode packets bottom up till application layer, if it find some sensitive keywords, RST packet will be sent to your device, connection broken. We can verify it, first, make sure you don&amp;rsquo;t surf internet via proxy, and then, capture packets when you search some sensitive keywords, from the packets your captured, you can see the time interval between your request packet and RST reply packet is much less than the interval between two continuous packets when connection establish, and after RST packet, Google server&amp;rsquo;s search reply packet arrive, too, and we can check TTL value in IP header, you can find TTL value in RST packet is much different from other packets from Google server. TTL means time to live, when one packet send from a device, it have a initial value, which usually is 128, or 255, every time this packet pass through a device, its value will decrease 1, if its value reach 0, this packet will be drop silently, from TTL value, you can how far it is your device from Google server,  and you can know how far firewall from your device. And the path go to and back from Google server may different, which depends on route protocols, TTL value may have a little difference from time to time, but usually the difference can&amp;rsquo;t reach more than 3 roughly, except the whole internet fluctuate a lot, that seems never happens so far, if it does, it will be a big news.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/ttl.png&quot; alt=&quot;TTL&quot;&gt;&lt;br&gt;
&lt;center&gt;&lt;small&gt;Figure 1:Time to live snapshot&lt;/small&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Time to break restriction&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;From analysis above, I think you already know how firewall system work, so now, we start to break it.&lt;/p&gt;

&lt;p&gt;Break restriction 1:&lt;/p&gt;

&lt;p&gt;Remember I mentioned above, for a big company like Google, it has a large IP pool, if you try to get Google&amp;rsquo;s IP address via DNS query inside firewall system, it must fail, all the IP addresses you get inside are blocked directly, they are already listed in black list. &lt;/p&gt;

&lt;p&gt;One way to get a valid Google server IP address is try to get it from outside DNS servers, like some DNS servers in some country outside firewall system, you know Google have many servers in different countries, that can help user in different country getting better experience, and DNS server will return DNS request with Google server&amp;rsquo;s IP address in its own country first, maybe you will ask how can we get IP address from outside DNS servers, there are some online ping website, some ping website can ping the domain name you specified, like Google.com, from different countries at the same time, and return some valid IP address to you if ping that domain name succeed, normally, these IP addresses are different, after you get these IP address, you can just input these IP addresses in your browser one by one, if you are lucky, Google search page will show on the screen. Google search page are the default page if you just input IP address in browser, for now, you can just use Google&amp;rsquo;s search service, other services like maps, Gmail, youtube, and etc, you still can&amp;rsquo;t use, which I will talk about it in later article.&lt;/p&gt;

&lt;p&gt;Another way to search some valid Google server IP addresses is iterate Google&amp;rsquo;s IP pool, but you need more advanced skills, whois utility can be use to search Google&amp;rsquo;s IP pool, and there are some whois websites you can search at, IP pools is very large, it is pretty hard to ping them by hand,  one by one. There are many packets generator tools online, which can construct ping packets, it can iterate the whole IP pool in short time, after checking IP address ping succeed, you can get some valid IP addresses, or you can write a script via python, shell, and etc, and check the ping successful IP addresses.&lt;/p&gt;

&lt;p&gt;Break restriction 2:&lt;/p&gt;

&lt;p&gt;For keyword filter system, it can work, that is because the connection between your device and Google server is not encrypted, anyone in the middle can see it, you should use a secure one, which is HTTPS connection, when you open Google website, try to input https://www.google.com, instead of www.google.com, or just google.com.&lt;/p&gt;

&lt;p&gt;Access Google via HTTPS, all the context between your device and Google server are encrypted, there is no way to decrypted them in the middle, even firewall system can get, but it has no way to know what it is.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/google.png&quot; alt=&quot;google&quot;&gt;&lt;br&gt;
&lt;center&gt;&lt;small&gt;Figure 2:google search snapshot&lt;/small&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;Ok, time to stop, if any questions, you can drop me a email, next article I will talk about how to visit youtube inside firewall system.&lt;br&gt;
Fix me, if you find some errors in my post.&lt;/p&gt;
</description>
        <pubDate>Mon, 02 Mar 2015 20:20:18 +0800</pubDate>
        <link>http://helloweishi.github.io//network/firewall/2015/03/02/access-google-without-vpn/</link>
        <guid isPermaLink="true">http://helloweishi.github.io//network/firewall/2015/03/02/access-google-without-vpn/</guid>
      </item>
    
  </channel>
</rss>
